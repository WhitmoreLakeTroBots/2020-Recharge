// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package frc.robot.subsystems;


import com.revrobotics.CANEncoder;
import com.revrobotics.CANPIDController;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.ColorMatch;
import com.revrobotics.ColorMatchResult;
import com.revrobotics.ColorSensorV3;
import com.revrobotics.ControlType;

import edu.wpi.first.wpilibj.I2C;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.util.Color;
import frc.robot.Robot;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class subChassis extends Subsystem {

    public static CANSparkMax leftDrive;
    public static CANSparkMax rightDrive;
    public static CANEncoder leftEncoder;
    public static CANEncoder righEncoder;
    public static int leftDriveCANID = 2;
    public static int rightDriveCANID = 7;
    public static final double joyDriveDeadband = 0.5;
    public static final double chassisLeftSideScalar = 1;
    public static final double chassisRightSideScalar = 1;
    public final boolean chassisSquareJoyInput = true;

    
    private final I2C.Port i2cPort = I2C.Port.kOnboard;
    private final ColorSensorV3 colorSensor = new ColorSensorV3(i2cPort);

   

    private final Color kBlueTarget = ColorMatch.makeColor(0.143, 0.427, 0.429);
  private final Color kGreenTarget = ColorMatch.makeColor(0.197, 0.561, 0.240);
  private final Color kRedTarget = ColorMatch.makeColor(0.561, 0.232, 0.114);
  private final Color kYellowTarget = ColorMatch.makeColor(0.361, 0.524, 0.113);
  private final ColorMatch colorMatcher = new ColorMatch();
  private DifferentialDrive robotDrive;
  private Joystick leftStick;
  private Joystick rightStick;


 /* public void Drive(Joystick stick) {
    double joyX = leftStick.getX();
    double joyY = leftStick.getY();

    if (Math.abs(joyX) < joyDriveDeadband) {
        joyX = 0;
    } else if (Math.abs(joyY) < joyDriveDeadband) {
        joyY = 0;
    }

    double rightMotorThrottle;
    double leftMotorThrottle;
    if (Robot.isDriveInverted) {
        rightMotorThrottle = (joyX + joyY) * chassisRightSideScalar;
        leftMotorThrottle = (joyX - joyY) *  chassisLeftSideScalar;
        if (chassisSquareJoyInput) {
            double rightSignum = Math.signum(rightMotorThrottle);
            double leftSignum = Math.signum(leftMotorThrottle);
            rightMotorThrottle = Math.pow(rightMotorThrottle, 2) * rightSignum;
            leftMotorThrottle = Math.pow(leftMotorThrottle, 2) * leftSignum;
        }
        
        setLeftMotors(leftMotorThrottle);
        setRightMotors(rightMotorThrottle);

    } else {
        rightMotorThrottle = (joyX - joyY) * chassisRightSideScalar;
        leftMotorThrottle = (joyX + joyY) * chassisLeftSideScalar;
        if (chassisSquareJoyInput) {
            double rightSignum = Math.signum(rightMotorThrottle);
            double leftSignum = Math.signum(leftMotorThrottle);
            rightMotorThrottle = Math.pow(rightMotorThrottle, 2) * rightSignum;
            leftMotorThrottle = Math.pow(leftMotorThrottle, 2) * leftSignum;
        }
        
        setLeftMotors(leftMotorThrottle);
        setRightMotors(rightMotorThrottle);
    }
    */
//}
    public void setLeftMotors(double throttle) {
        leftDrive.set(throttle);
    }
    public void setRightMotors(double throttle) {
         rightDrive.set(throttle);
    }

    public subChassis() {
        leftDrive = new CANSparkMax(leftDriveCANID, MotorType.kBrushless);
        rightDrive = new CANSparkMax(rightDriveCANID, MotorType.kBrushless);
        leftStick = new Joystick(0);
        rightStick = new Joystick(1);
        leftDrive.restoreFactoryDefaults();
        rightDrive.restoreFactoryDefaults();
        leftEncoder = leftDrive.getEncoder();
                                                robotDrive = new DifferentialDrive(leftDrive, rightDrive);
        colorMatcher.addColorMatch(kBlueTarget);
        colorMatcher.addColorMatch(kGreenTarget);
        colorMatcher.addColorMatch(kRedTarget);
        colorMatcher.addColorMatch(kYellowTarget);
        //rightEncoder = rightDrive.getEncoder();
        
        
        
    
       
    }

    @Override
    public void initDefaultCommand() {
        
    }

    @Override
    public void periodic() {
        Color detectedColor = colorSensor.getColor();
        String colorString;
    ColorMatchResult match = colorMatcher.matchClosestColor(detectedColor);

    if (match.color == kBlueTarget) {
      colorString = "Blue";
    } else if (match.color == kRedTarget) {
      colorString = "Red";
    } else if (match.color == kGreenTarget) {
      colorString = "Green";
    } else if (match.color == kYellowTarget) {
      colorString = "Yellow";
    } else {
      colorString = "Unknown";
    }
    SmartDashboard.putNumber("Red", detectedColor.red);
    SmartDashboard.putNumber("Green", detectedColor.green);
    SmartDashboard.putNumber("Blue", detectedColor.blue);
    SmartDashboard.putNumber("Confidence", match.confidence);
    SmartDashboard.putString("Detected Color", colorString);
                                                                robotDrive.tankDrive(leftStick.getY(), rightStick.getY());
    
    
   
    }
    /*if(m_encoder.getPosition() / 4 > setPoint / 4 && smartBool == false ){
      pidController.setSmartMotionMaxVelocity(maxVel / 2, 0);
      smartBool = true;
    }
    if(m_encoder.getPosition() / 2 > setPoint / 2 && smartBool1 == false ){
      pidController.setSmartMotionMaxVelocity(maxVel, 0);
      smartBool1 = true;
    }*/
  
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
}

