package frc.robot.subsystems;

import com.revrobotics.CANEncoder;
import com.revrobotics.CANError;
import com.revrobotics.CANPIDController;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.ControlType;
import com.revrobotics.CANSparkMax.IdleMode;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Subsystem;
import frc.robot.CommonLogic;
import frc.robot.Settings;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class subChassis extends Subsystem {

  public static CANSparkMax leftDrive;
  public static CANSparkMax rightDrive;
  public static CANEncoder leftEncoder;
  public static CANEncoder rightEncoder;
  public static CANPIDController leftPidC = null;
  public static CANPIDController rightPidC = null;

  public static final double joyDriveDeadband = 0.05;
  public static final double driveStraightGyroKp = 0.05;
  public static final double wheelDiameter = 6.0;
  public static final double gearBoxRatio = 8.45;
  private Joystick leftStick;
  

  public subChassis() {
    
    leftDrive = new CANSparkMax(Settings.CANID_subChassisLeftMaster, MotorType.kBrushless);
    rightDrive = new CANSparkMax(Settings.CANID_subChassisRightMaster, MotorType.kBrushless);
    leftStick = new Joystick(0);
    leftDrive.restoreFactoryDefaults();
    rightDrive.restoreFactoryDefaults();
    
    
    leftDrive.setInverted(true);
    
    leftDrive.setIdleMode(IdleMode.kBrake);
    rightDrive.setIdleMode(IdleMode.kBrake);

    leftEncoder = leftDrive.getEncoder();
    rightEncoder = rightDrive.getEncoder();

    rightPidC = rightDrive.getPIDController();
    leftPidC = leftDrive.getPIDController();

    configureSmartMotion();
    configureTeleOptMotion();
    
    // burn in the values so they stay during a brown out.
    rightDrive.burnFlash();
    leftDrive.burnFlash();

  }

  public static class smartMotionKs {
    public final static int slot = 0;
    public final static double kP = 5e-4;
    public final static double kI = 1e-6;
    public final static double kD = 0;
    public final static double kIz = 0;
    public final static double kFF = 0.000156;
    public final static double kMaxOutput = 1;
    public final static double kMinOutput = -1;
    public final static int maxRPM = 4130;
    public final static int minRPM = -maxRPM;
    // allow .5 seconds to reach max RPM
    public final static int maxAcc = maxRPM * 4;
    public final static int allowedErr = maxRPM /10;

  }

  public static class teleOpMotionKs {
    public final static int slot = 1;
    public final static double kP = 1e-4;//5e-4;
    public final static double kI = 1e-6;//1e-6;//1e-5;
    public final static double kD = 0;
    public final static double kIz = 0;
    public final static double kFF = 0;//0.000156;
    public final static double kMaxOutput = 1;
    public final static double kMinOutput = -1;
    public final static int maxRPM = 5000;
    public final static int minRPM = 0;
    // allow .5 seconds to reach max RPM
    public final static int maxAcc = maxRPM * 10;
    public final static int allowedErr = maxRPM /10;

  }

  public void Drive(Joystick stick) {

    double joyX = CommonLogic.joyDeadBand(stick.getX(), joyDriveDeadband);
    double joyY = CommonLogic.joyDeadBand(stick.getY(), joyDriveDeadband);
    setVelocity_RightDrive((joyY + joyX) * teleOpMotionKs.maxRPM);
    setVelocity_LeftDrive((joyY - joyX) * teleOpMotionKs.maxRPM); 


  }

  private void configureSmartMotion() {
    // configures smart motion for the drive train sparks
    CANError err = CANError.kOk;

    err = leftPidC.setP(smartMotionKs.kP, smartMotionKs.slot);
    
    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = rightPidC.setP(smartMotionKs.kP, smartMotionKs.slot);

    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = leftPidC.setI(smartMotionKs.kI, smartMotionKs.slot);
    
    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = rightPidC.setI(smartMotionKs.kI, smartMotionKs.slot);

    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = leftPidC.setD(smartMotionKs.kD, smartMotionKs.slot);
    
    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = rightPidC.setD(smartMotionKs.kD, smartMotionKs.slot);

    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = leftPidC.setIZone(smartMotionKs.kIz, smartMotionKs.slot);
    
    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = leftPidC.setIZone(smartMotionKs.kIz, smartMotionKs.slot);

    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = leftPidC.setFF(smartMotionKs.kFF, smartMotionKs.slot);
    
    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = rightPidC.setFF(smartMotionKs.kFF, smartMotionKs.slot);

    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = leftPidC.setOutputRange(smartMotionKs.kMinOutput, smartMotionKs.kMaxOutput, smartMotionKs.slot);
    
    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = rightPidC.setOutputRange(smartMotionKs.kMinOutput, smartMotionKs.kMaxOutput, smartMotionKs.slot);

    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = rightPidC.setSmartMotionMaxVelocity(smartMotionKs.maxRPM, smartMotionKs.slot);
    
    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = rightPidC.setSmartMotionMinOutputVelocity(smartMotionKs.maxRPM,smartMotionKs.slot);  
    
    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = rightPidC.setSmartMotionMaxAccel(smartMotionKs.maxAcc,smartMotionKs.slot);
    
    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    }  
    err = leftPidC.setSmartMotionMaxVelocity(smartMotionKs.maxRPM, smartMotionKs.slot);
    
    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = leftPidC.setSmartMotionMinOutputVelocity(smartMotionKs.maxRPM,smartMotionKs.slot);  
    
    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = leftPidC.setSmartMotionMaxAccel(smartMotionKs.maxAcc,smartMotionKs.slot);

    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = leftPidC.setSmartMotionAllowedClosedLoopError(0, smartMotionKs.slot);
    
    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    err = rightPidC.setSmartMotionAllowedClosedLoopError(0, smartMotionKs.slot);

    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
  }
  /****************************************************************************
    Velocity Settings & Methods
  **************************************
  **************************************/
  private void configureTeleOptMotion() {
    // configures TeleOp motion for the drive train sparks
    leftPidC.setP(teleOpMotionKs.kP, teleOpMotionKs.slot);
    rightPidC.setP(teleOpMotionKs.kP, teleOpMotionKs.slot);

    leftPidC.setD(teleOpMotionKs.kD, teleOpMotionKs.slot);
    rightPidC.setD(teleOpMotionKs.kD, teleOpMotionKs.slot);

    leftPidC.setI(teleOpMotionKs.kI, teleOpMotionKs.slot);
    rightPidC.setI(teleOpMotionKs.kI, teleOpMotionKs.slot);

    leftPidC.setIZone(teleOpMotionKs.kIz, teleOpMotionKs.slot);
    rightPidC.setIZone(teleOpMotionKs.kIz, teleOpMotionKs.slot);

    leftPidC.setFF(teleOpMotionKs.kFF, teleOpMotionKs.slot);
    rightPidC.setFF(teleOpMotionKs.kFF, teleOpMotionKs.slot);

    leftPidC.setOutputRange(teleOpMotionKs.kMinOutput, teleOpMotionKs.kMaxOutput, teleOpMotionKs.slot);
    rightPidC.setOutputRange(teleOpMotionKs.kMinOutput, teleOpMotionKs.kMaxOutput, teleOpMotionKs.slot);

    leftPidC.setSmartMotionMaxVelocity(teleOpMotionKs.maxRPM, teleOpMotionKs.slot);
    rightPidC.setSmartMotionMaxVelocity(teleOpMotionKs.maxRPM, teleOpMotionKs.slot);

    leftPidC.setSmartMotionMinOutputVelocity(teleOpMotionKs.minRPM, teleOpMotionKs.slot);
    rightPidC.setSmartMotionMinOutputVelocity(teleOpMotionKs.minRPM, teleOpMotionKs.slot);

    leftPidC.setSmartMotionMaxAccel(teleOpMotionKs.maxAcc, teleOpMotionKs.slot);
    rightPidC.setSmartMotionMaxAccel(teleOpMotionKs.maxAcc, teleOpMotionKs.slot);
    
    leftPidC.setSmartMotionAllowedClosedLoopError(teleOpMotionKs.allowedErr, teleOpMotionKs.slot);
    rightPidC.setSmartMotionAllowedClosedLoopError(teleOpMotionKs.allowedErr, teleOpMotionKs.slot);

  }

  public void setVelocity_LeftDrive (double velRPM) {
    double RPM = CommonLogic.CapMotorPower(velRPM, -teleOpMotionKs.maxRPM, teleOpMotionKs.maxRPM);
    leftPidC.setReference(RPM, ControlType.kVelocity, teleOpMotionKs.slot);
    
}

  public void setVelocity_RightDrive (double velRPM) {
    double RPM = CommonLogic.CapMotorPower(velRPM, -teleOpMotionKs.maxRPM, teleOpMotionKs.maxRPM);
    rightPidC.setReference(RPM, ControlType.kVelocity, teleOpMotionKs.slot);
    

  }

  /****************************************************************************
    Position Settings & Methods
  ****************************************************************************/
  public void setSmartPosition_LeftDrive(double ref_Revs, double RPM){
    // sets left motor to run to position
    leftEncoder.setPosition(0);
    CANError err = CANError.kOk;
    err = leftPidC.setReference(ref_Revs, ControlType.kSmartMotion);
    
    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
    
    err= leftPidC.setSmartMotionMaxVelocity(RPM, smartMotionKs.slot);
    if (err != CANError.kOk){
      System.err.println("setSmartMotionMaxVelocity returned " + err);
    }
    //leftPidC.setSmartMotionMinOutputVelocity(RPM,smartMotionKs.slot);  
   
  }

  public  void setSmartPosition_RightDrive (double ref_Revs, double RPM) {
    // sets right motor to run to position
   rightEncoder.setPosition(0);
   
    CANError err = CANError.kOk;
    err=rightPidC.setReference(ref_Revs, ControlType.kSmartMotion, smartMotionKs.slot);
    
    if (err != CANError.kOk){
      System.err.println("setReference returned" + err);
    } 
   
    err=rightPidC.setSmartMotionMaxVelocity(RPM, smartMotionKs.slot);
    
    if (err != CANError.kOk){
      System.err.println("setSmartMotionMaxVelocity returned " + err);
    }
   
    //rightPidC.setSmartMotionMinOutputVelocity(RPM,smartMotionKs.slot);  

  }

  public double inches2MotorRevs (double inches) {
    // convert inches to motor Revs
    return (inches / wheelDiameter / Math.PI * gearBoxRatio);
    // 72 / 6 / Math.P * 8.45 = 32.2766224
  }

  public double inches_sec2RPM (double inches_sec) {
    // converts inches/sec to Revs/minute
    return inches2MotorRevs(inches_sec) * 60;
  }

  public void smartPosition_steerStraight(double leftRPM, double rightRPM, double tol){
    // steer the robot by changing the smartMotion velocity of the left and right sides of the chassis
    double loTol = 1 - tol;
    double hiTol = 1 + tol;

    // sets max and min motion velocity to steer while driving to position
    leftPidC.setSmartMotionMaxVelocity(leftRPM * hiTol, smartMotionKs.slot);
    rightPidC.setSmartMotionMaxVelocity(rightRPM * hiTol, smartMotionKs.slot);
    
    leftPidC.setSmartMotionMinOutputVelocity(leftRPM * loTol, smartMotionKs.slot);
    rightPidC.setSmartMotionMinOutputVelocity(rightRPM * loTol, smartMotionKs.slot);
    
  }

  public boolean smartPosition_isDoneLeft (double desired_Revs, double Tol) {
    
    double currPos = leftEncoder.getPosition();
    return CommonLogic.isInRange(currPos, desired_Revs, Tol);
  }
  
  public boolean smartPosition_isDoneRight (double desired_Revs, double Tol) {
    
    double currPos = rightEncoder.getPosition();
    return CommonLogic.isInRange(currPos, desired_Revs, Tol);
  }

  public boolean smartPosition_LR_isDone(double desired_Revs, double Tol) {

    return (smartPosition_isDoneRight(desired_Revs, Tol) && 
            smartPosition_isDoneLeft(desired_Revs, Tol) );
   
  }

  @Override
  public void initDefaultCommand() {

  }

  @Override
  public void periodic() {
    Drive(leftStick);
  }

}