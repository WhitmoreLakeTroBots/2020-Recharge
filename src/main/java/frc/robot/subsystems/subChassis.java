// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package frc.robot.subsystems;


import com.revrobotics.CANEncoder;
import com.revrobotics.CANPIDController;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.ColorMatch;
import com.revrobotics.ColorMatchResult;
import com.revrobotics.ColorSensorV3;
import com.revrobotics.ControlType;

import edu.wpi.first.wpilibj.I2C;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.util.Color;
import frc.robot.Robot;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class subChassis extends Subsystem {

    public CANSparkMax leftDrive;
    public CANSparkMax rightDrive;
    public CANEncoder leftEncoder;
    public CANEncoder righEncoder;
    public static int leftDriveCANID = 2;
    public static int rightDriveCANID = 7;
    public static final double joyDriveDeadband = 0.5;
    public static final double chassisLeftSideScalar = 1;
    public static final double chassisRightSideScalar = 1;
    public final boolean chassisSquareJoyInput = true;

    private CANPIDController pidController;
    private final I2C.Port i2cPort = I2C.Port.kOnboard;
    private final ColorSensorV3 colorSensor = new ColorSensorV3(i2cPort);

    public double kP, kI, kD, kIz, kFF, kMaxOutput, kMinOutput, maxRPM, maxVel, minVel, maxAcc, allowedErr;

    private final Color kBlueTarget = ColorMatch.makeColor(0.143, 0.427, 0.429);
  private final Color kGreenTarget = ColorMatch.makeColor(0.197, 0.561, 0.240);
  private final Color kRedTarget = ColorMatch.makeColor(0.561, 0.232, 0.114);
  private final Color kYellowTarget = ColorMatch.makeColor(0.361, 0.524, 0.113);
  private final ColorMatch colorMatcher = new ColorMatch();
  private DifferentialDrive robotDrive;
  private Joystick leftStick;
  private Joystick rightStick;


  public void Drive(Joystick stick) {
    double joyX = leftStick.getX();
    double joyY = leftStick.getY();

    if (Math.abs(joyX) < joyDriveDeadband) {
        joyX = 0;
    } else if (Math.abs(joyY) < joyDriveDeadband) {
        joyY = 0;
    }

    double rightMotorThrottle;
    double leftMotorThrottle;
    if (Robot.isDriveInverted) {
        rightMotorThrottle = (joyX + joyY) * chassisRightSideScalar;
        leftMotorThrottle = (joyX - joyY) *  chassisLeftSideScalar;
        if (chassisSquareJoyInput) {
            double rightSignum = Math.signum(rightMotorThrottle);
            double leftSignum = Math.signum(leftMotorThrottle);
            rightMotorThrottle = Math.pow(rightMotorThrottle, 2) * rightSignum;
            leftMotorThrottle = Math.pow(leftMotorThrottle, 2) * leftSignum;
        }
        
        setLeftMotors(leftMotorThrottle);
        setRightMotors(rightMotorThrottle);

    } else {
        rightMotorThrottle = (joyX - joyY) * chassisRightSideScalar;
        leftMotorThrottle = (joyX + joyY) * chassisLeftSideScalar;
        if (chassisSquareJoyInput) {
            double rightSignum = Math.signum(rightMotorThrottle);
            double leftSignum = Math.signum(leftMotorThrottle);
            rightMotorThrottle = Math.pow(rightMotorThrottle, 2) * rightSignum;
            leftMotorThrottle = Math.pow(leftMotorThrottle, 2) * leftSignum;
        }
        
        setLeftMotors(leftMotorThrottle);
        setRightMotors(rightMotorThrottle);
    }
}
    public void setLeftMotors(double throttle) {
        leftDrive.set(throttle);
    }
    public void setRightMotors(double throttle) {
         rightDrive.set(throttle);
    }

    public subChassis() {
        leftDrive = new CANSparkMax(leftDriveCANID, MotorType.kBrushless);
        rightDrive = new CANSparkMax(rightDriveCANID, MotorType.kBrushless);
        leftStick = new Joystick(0);
        rightStick = new Joystick(1);
        leftDrive.restoreFactoryDefaults();
        rightDrive.restoreFactoryDefaults();
        leftEncoder = leftDrive.getEncoder();
                                                //robotDrive = new DifferentialDrive(leftDrive, rightDrive);
        colorMatcher.addColorMatch(kBlueTarget);
        colorMatcher.addColorMatch(kGreenTarget);
        colorMatcher.addColorMatch(kRedTarget);
        colorMatcher.addColorMatch(kYellowTarget);
        //rightEncoder = rightDrive.getEncoder();
        pidController = leftDrive.getPIDController();
        
        
    
        // PID coefficients
        kP = 5e-5; 
        kI = 1e-6;
        kD = 0; 
        kIz = 0; 
        kFF = 0.000156; 
        kMaxOutput = 1; 
        kMinOutput = -1;
        maxRPM = 5700;
    
        // Smart Motion Coefficients
        maxVel = 3500; // rpm
        maxAcc = 1500;
    
        // set PID coefficients
        pidController.setP(kP);
        pidController.setI(kI);
        pidController.setD(kD);
        pidController.setIZone(kIz);
        pidController.setFF(kFF);
        pidController.setOutputRange(kMinOutput, kMaxOutput);
    
    
       
        /**
         * Smart Motion coefficients are set on a CANPIDController object
         * 
         * - setSmartMotionMaxVelocity() will limit the velocity in RPM of
         * the pid controller in Smart Motion mode
         * - setSmartMotionMinOutputVelocity() will put a lower bound in
         * RPM of the pid controller in Smart Motion mode
         * - setSmartMotionMaxAccel() will limit the acceleration in RPM^2
         * of the pid controller in Smart Motion mode
         * - setSmartMotionAllowedClosedLoopError() will set the max allowed
         * error for the pid controller in Smart Motion mode
         */
        int smartMotionSlot = 0;
        pidController.setSmartMotionMaxVelocity(maxVel, smartMotionSlot);
        pidController.setSmartMotionMinOutputVelocity(minVel, smartMotionSlot);
        pidController.setSmartMotionMaxAccel(maxAcc, smartMotionSlot);
        pidController.setSmartMotionAllowedClosedLoopError(allowedErr, smartMotionSlot);
    
        // display PID coefficients on SmartDashboard
        SmartDashboard.putNumber("P Gain", kP);
        SmartDashboard.putNumber("I Gain", kI);
        SmartDashboard.putNumber("D Gain", kD);
        SmartDashboard.putNumber("I Zone", kIz);
        SmartDashboard.putNumber("Feed Forward", kFF);
        SmartDashboard.putNumber("Max Output", kMaxOutput);
        SmartDashboard.putNumber("Min Output", kMinOutput);
    
        // display Smart Motion coefficients
        SmartDashboard.putNumber("Max Velocity", maxVel);
        SmartDashboard.putNumber("Min Velocity", minVel);
        SmartDashboard.putNumber("Max Acceleration", maxAcc);
        SmartDashboard.putNumber("Allowed Closed Loop Error", allowedErr);
        SmartDashboard.putNumber("Set Position", 0);
        SmartDashboard.putNumber("Set Velocity", 0);
    
        // button to toggle between velocity and smart motion modes
        SmartDashboard.putBoolean("Mode", true);
    }

    @Override
    public void initDefaultCommand() {
        
    }

    @Override
    public void periodic() {
        Color detectedColor = colorSensor.getColor();
        String colorString;
    ColorMatchResult match = colorMatcher.matchClosestColor(detectedColor);

    if (match.color == kBlueTarget) {
      colorString = "Blue";
    } else if (match.color == kRedTarget) {
      colorString = "Red";
    } else if (match.color == kGreenTarget) {
      colorString = "Green";
    } else if (match.color == kYellowTarget) {
      colorString = "Yellow";
    } else {
      colorString = "Unknown";
    }
    SmartDashboard.putNumber("Red", detectedColor.red);
    SmartDashboard.putNumber("Green", detectedColor.green);
    SmartDashboard.putNumber("Blue", detectedColor.blue);
    SmartDashboard.putNumber("Confidence", match.confidence);
    SmartDashboard.putString("Detected Color", colorString);
                                                                //robotDrive.tankDrive(leftStick.getY(), rightStick.getY());
    
    
    // read PID coefficients from SmartDashboard
    double p = SmartDashboard.getNumber("P Gain", 0);
    double i = SmartDashboard.getNumber("I Gain", 0);
    double d = SmartDashboard.getNumber("D Gain", 0);
    double iz = SmartDashboard.getNumber("I Zone", 0);
    double ff = SmartDashboard.getNumber("Feed Forward", 0);
    double max = SmartDashboard.getNumber("Max Output", 0);
    double min = SmartDashboard.getNumber("Min Output", 0);
    double maxV = SmartDashboard.getNumber("Max Velocity", 0);
    double minV = SmartDashboard.getNumber("Min Velocity", 0);
    double maxA = SmartDashboard.getNumber("Max Acceleration", 0);
    double allE = SmartDashboard.getNumber("Allowed Closed Loop Error", 0);

    // if PID coefficients on SmartDashboard have changed, write new values to controller
    if((p != kP)) { pidController.setP(p); kP = p; }
    if((i != kI)) { pidController.setI(i); kI = i; }
    if((d != kD)) { pidController.setD(d); kD = d; }
    if((iz != kIz)) { pidController.setIZone(iz); kIz = iz; }
    if((ff != kFF)) { pidController.setFF(ff); kFF = ff; }
    if((max != kMaxOutput) || (min != kMinOutput)) { 
      pidController.setOutputRange(min, max); 
      kMinOutput = min; kMaxOutput = max; 
    }
    if((maxV != maxVel)) { pidController.setSmartMotionMaxVelocity(maxV,0); maxVel = maxV; }
    if((minV != minVel)) { pidController.setSmartMotionMinOutputVelocity(minV,0); minVel = minV; }
    if((maxA != maxAcc)) { pidController.setSmartMotionMaxAccel(maxA,0); maxAcc = maxA; }
    if((allE != allowedErr)) { pidController.setSmartMotionAllowedClosedLoopError(allE,0); allowedErr = allE; }

    double setPoint, processVariable;
    boolean mode = SmartDashboard.getBoolean("Mode", false);
    if(mode) {
      setPoint = SmartDashboard.getNumber("Set Velocity", 0);
      pidController.setReference(setPoint, ControlType.kVelocity);
      processVariable = leftEncoder.getVelocity();
    } else {
      setPoint = SmartDashboard.getNumber("Set Position", 0) /(6 * Math.PI);
      /**
       * As with other PID modes, Smart Motion is set by calling the
       * setReference method on an existing pid object and setting
       * the control type to kSmartMotion
       */
      pidController.setReference(setPoint, ControlType.kSmartMotion);
      processVariable = leftEncoder.getPosition();
    }
    /*if(m_encoder.getPosition() / 4 > setPoint / 4 && smartBool == false ){
      pidController.setSmartMotionMaxVelocity(maxVel / 2, 0);
      smartBool = true;
    }
    if(m_encoder.getPosition() / 2 > setPoint / 2 && smartBool1 == false ){
      pidController.setSmartMotionMaxVelocity(maxVel, 0);
      smartBool1 = true;
    }*/
    SmartDashboard.putNumber("SetPoint", setPoint);
    SmartDashboard.putNumber("Process Variable", processVariable);
    SmartDashboard.putNumber("Output", leftDrive.getAppliedOutput());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    }
}

