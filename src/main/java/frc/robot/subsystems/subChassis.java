// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import com.revrobotics.CANEncoder;
import com.revrobotics.CANPIDController;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.ColorMatch;
import com.revrobotics.ColorMatchResult;
import com.revrobotics.ColorSensorV3;

import edu.wpi.first.wpilibj.I2C;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.util.Color;
import frc.robot.CommonLogic;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class subChassis extends Subsystem {

  public static CANSparkMax leftDrive;
  public static CANSparkMax rightDrive;
  public static CANEncoder leftEncoder;
  public static CANEncoder righEncoder;
  public static int leftDriveCANID = 2;
  public static int rightDriveCANID = 7;
  public static final double joyDriveDeadband = 0.6;
  public static final double chassisLeftSideScalar = 1;
  public static final double chassisRightSideScalar = 1;
  public final boolean chassisSquareJoyInput = true;

  public static CANSparkMax flywheelMotor;

  private final I2C.Port i2cPort = I2C.Port.kOnboard;
  private final ColorSensorV3 colorSensor = new ColorSensorV3(i2cPort);

  private final Color kBlueTarget = ColorMatch.makeColor(0.143, 0.427, 0.429);
  private final Color kGreenTarget = ColorMatch.makeColor(0.197, 0.561, 0.240);
  private final Color kRedTarget = ColorMatch.makeColor(0.561, 0.232, 0.114);
  private final Color kYellowTarget = ColorMatch.makeColor(0.361, 0.524, 0.113);
  private final ColorMatch colorMatcher = new ColorMatch();
  private DifferentialDrive robotDrive;
  public Joystick leftStick;
  private Joystick rightStick;
  private static boolean isDriveInverted = false;
  public static double kP, kI, kD, kIz, kFF, kMaxOutput, kMinOutput, maxRPM, maxVel, minVel, maxAcc, allowedErr;
  public static CANPIDController m_pidController;
  public static double getEncoderRevs;

  double rightMotorThrottle;
  double leftMotorThrottle;
  

  public subChassis() {
    leftDrive = new CANSparkMax(leftDriveCANID, MotorType.kBrushless);
    rightDrive = new CANSparkMax(rightDriveCANID, MotorType.kBrushless);
    leftStick = new Joystick(0);
    rightStick = new Joystick(1);
    leftDrive.restoreFactoryDefaults();
    rightDrive.restoreFactoryDefaults();
    leftEncoder = leftDrive.getEncoder();
    // robotDrive = new DifferentialDrive(leftDrive, rightDrive);
    colorMatcher.addColorMatch(kBlueTarget);
    colorMatcher.addColorMatch(kGreenTarget);
    colorMatcher.addColorMatch(kRedTarget);
    colorMatcher.addColorMatch(kYellowTarget);
    // rightEncoder = rightDrive.getEncoder();
    getEncoderRevs = leftEncoder.getPosition();

  }

  public void Drive(Joystick stick) {
    double joyX = leftStick.getX();
    double joyY = leftStick.getY();

    if (Math.abs(joyX) < joyDriveDeadband / 2.5) {
      joyX = 0;
    } else if (Math.abs(joyY) < joyDriveDeadband) {
      joyY = 0;
    }

    

    setLeftMotors(leftMotorThrottle);
    setRightMotors(rightMotorThrottle);
    System.err.println("DRIVING");

    rightMotorThrottle = (joyX - joyY) * chassisRightSideScalar;
    leftMotorThrottle = (joyX + joyY) * chassisLeftSideScalar;

    rightMotorThrottle = CommonLogic.joyStickMath(rightMotorThrottle);
    leftMotorThrottle = CommonLogic.joyStickMath(leftMotorThrottle);

    setLeftMotors(leftMotorThrottle);
    setRightMotors(rightMotorThrottle);
    String LMT = String.format("Left Motor Throttle %1.3f Right Motor Throttle %1.3f", leftMotorThrottle,
        rightMotorThrottle);
    System.out.println(LMT);

  }

  public void setLeftMotors(double throttle) {
    leftDrive.set(throttle);
  }

  public void setRightMotors(double throttle) {
    rightDrive.set(throttle);
  }
  public void activateSmartMotion(){
    leftDrive.restoreFactoryDefaults();

    // initialze PID controller and encoder objects
    m_pidController = leftDrive.getPIDController();
    leftEncoder = leftDrive.getEncoder();

    // PID coefficients
    kP = 5e-5; 
    kI = 1e-6;
    kD = 0; 
    kIz = 0; 
    kFF = 0.000156; 
    kMaxOutput = 1; 
    kMinOutput = -1;
    maxRPM = 5700;

    // Smart Motion Coefficients
    maxVel = 2000; // rpm
    maxAcc = 1500;

    // set PID coefficients
    m_pidController.setP(kP);
    m_pidController.setI(kI);
    m_pidController.setD(kD);
    m_pidController.setIZone(kIz);
    m_pidController.setFF(kFF);
    m_pidController.setOutputRange(kMinOutput, kMaxOutput);

    int smartMotionSlot = 0;
    m_pidController.setSmartMotionMaxVelocity(maxVel, smartMotionSlot);
    m_pidController.setSmartMotionMinOutputVelocity(minVel, smartMotionSlot);
    m_pidController.setSmartMotionMaxAccel(maxAcc, smartMotionSlot);
    m_pidController.setSmartMotionAllowedClosedLoopError(allowedErr, smartMotionSlot);

    // display PID coefficients on SmartDashboard
    SmartDashboard.putNumber("P Gain", kP);
    SmartDashboard.putNumber("I Gain", kI);
    SmartDashboard.putNumber("D Gain", kD);
    SmartDashboard.putNumber("I Zone", kIz);
    SmartDashboard.putNumber("Feed Forward", kFF);
    SmartDashboard.putNumber("Max Output", kMaxOutput);
    SmartDashboard.putNumber("Min Output", kMinOutput);

    // display Smart Motion coefficients
    SmartDashboard.putNumber("Max Velocity", maxVel);
    SmartDashboard.putNumber("Min Velocity", minVel);
    SmartDashboard.putNumber("Max Acceleration", maxAcc);
    SmartDashboard.putNumber("Allowed Closed Loop Error", allowedErr);
    SmartDashboard.putNumber("Set Position", 0);
    SmartDashboard.putNumber("Set Velocity", 0);

    // button to toggle between velocity and smart motion modes
    SmartDashboard.putBoolean("Mode", true);
  }

  @Override
  public void initDefaultCommand() {

  }

  @Override
  public void periodic() {

    Color detectedColor = colorSensor.getColor();
    String colorString;
    ColorMatchResult match = colorMatcher.matchClosestColor(detectedColor);

    if (match.color == kBlueTarget) {
      colorString = "Blue";
    } else if (match.color == kRedTarget) {
      colorString = "Red";
    } else if (match.color == kGreenTarget) {
      colorString = "Green";
    } else if (match.color == kYellowTarget) {
      colorString = "Yellow";
    } else {
      colorString = "Unknown";
    }
    SmartDashboard.putNumber("Red", detectedColor.red);
    SmartDashboard.putNumber("Green", detectedColor.green);
    SmartDashboard.putNumber("Blue", detectedColor.blue);
    SmartDashboard.putNumber("Confidence", match.confidence);
    SmartDashboard.putString("Detected Color", colorString);
    // robotDrive.tankDrive(leftStick.getY(), rightStick.getY());

  }
  /*
   * if(m_encoder.getPosition() / 4 > setPoint / 4 && smartBool == false ){
   * pidController.setSmartMotionMaxVelocity(maxVel / 2, 0); smartBool = true; }
   * if(m_encoder.getPosition() / 2 > setPoint / 2 && smartBool1 == false ){
   * pidController.setSmartMotionMaxVelocity(maxVel, 0); smartBool1 = true; }
   */

  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

  // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

  // Put methods for controlling this subsystem
  // here. Call these from Commands.

}
