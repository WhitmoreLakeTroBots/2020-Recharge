// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.commands;

import edu.wpi.first.wpilibj.command.Command;
import frc.robot.CommonLogic;
import frc.robot.PidConstants;
import frc.robot.Robot;
import frc.robot.Settings;
import frc.robot.motion_profile.MotionProfiler;

/**
 *
 */
public class Auto_DriveByGyro extends Command {

  private double _distance;
  private double _cruiseSpeed;
  private double _accel;
	private boolean _isFinished = false;
	private double _startTime;
	private double _requestedHeading = 0;
	private double _distanceSignum;
	private double _absDistance;
	private double _abortTime;
  private double _endTime;
  
	private MotionProfiler mp;
  

/**
 * Accepting a the motor velocities for left and right
 * sides of the robot to allow command to steer the robot using the 
 * default accelleration.
 * @param  dist_inces -- distance for the robot to move
 * @param  velInches_sec -- velocity in inches per sec
 * @param  heading_deg  -- desired heading in degrees
 **/
  public Auto_DriveByGyro(double dist_inches, double velInches_sec, double heading_deg) {
    requires(Robot.subChassis);
    _distance = dist_inches;
    _cruiseSpeed = velInches_sec;
    _requestedHeading = heading_deg;
    _accel = Settings.profileDriveAccelration;
  }

/**
 * Accepting the motor velocities for left and right
 * sides of the robot to allow command to steer the robot
 * @param  dist_inces -- distance for the robot to move
 * @param  velInches_sec -- velocity in inches per sec
 * @param  heading_deg  -- desired heading in degrees
 * @param  accel_sec_sec -- overide the accel with custom inches/sec/sec
 **/
  
/* public Auto_DriveByGyro(double dist_inches, double velInches_sec, double heading_deg, double accel_sec_sec) {
  requires(Robot.subChassis);
  _distance = dist_inches;
  _cruiseSpeed = velInches_sec;
  _requestedHeading = heading_deg;
  _accel = accel_sec_sec;
}
*/

  // Called just before this Command runs the first time
  @Override
  protected void initialize() {

    System.err.println("Auto_DriveByGyro.initialize()");
    // start the motion
    Robot.subChassis.resetEncoder_LeftDrive();
    Robot.subChassis.resetEncoder_RightDrive();
    _absDistance = Math.abs(_distance);
    _distanceSignum = Math.signum(_distance);
    _abortTime = _absDistance / _cruiseSpeed;
    mp = new MotionProfiler(_absDistance, 0, _cruiseSpeed, _accel);
    _endTime = mp._stopTime * Settings.profileEndTimeScalar;
    _startTime = CommonLogic.getTime();
    _isFinished = false;
  }

  // Called repeatedly when this Command is scheduled to run
  @Override
  protected void execute() {

    //double encoderVal = Robot.subChassis.getEncoderAvgDistInch();
		double deltaTime = CommonLogic.getTime() - _startTime;
		//double profileDist = mp.getTotalDistanceTraveled(deltaTime);
		double currentHeading = Robot.subGyro.getNormaliziedNavxAngle();
		double turnValue = calcTurnRate(currentHeading);
    double profileVelocity = mp.getProfileCurrVelocity(deltaTime);
    System.err.println("Profile Velocity: "+ profileVelocity + " Time " + deltaTime);

    double leftRPM = Robot.subChassis.inches_sec2RPM(profileVelocity - turnValue);
    double rightRPM = Robot.subChassis.inches_sec2RPM(profileVelocity + turnValue);
    Robot.subChassis.Drive(leftRPM, rightRPM);

    // see if we are really done with the move... call Tolerance as 1% of _distance
    //if (CommonLogic.isInRange(Robot.subChassis.getEncoder_Inches_LR(), _distance, (_distance * .01))) {
    //  _isFinished = true;
    // }

    // fail safe we end if time expires
    if (deltaTime > _endTime) {
			_isFinished = true;
    }
    
  }


  protected double calcTurnRate(double currentHeading) {
    
    double turnRate = CommonLogic.calcTurnRate(
        Robot.subGyro.deltaHeading(Robot.subGyro.getNormaliziedNavxAngle(), _requestedHeading),
        Robot.subChassis.driveStraightGyroKp);
    
        // turn rate must be expressed as RPMs
    return (turnRate * PidConstants.Chassis_teleOpMotionKs.maxRPM);
    
	}

  // Make this return true when this Command no longer needs to run execute()
  @Override
  protected boolean isFinished() {
    System.err.println("Auto_DriveByGyro.isFinished()");
    return _isFinished;
  }

  // Called once after isFinished returns true
  @Override
  protected void end() {
    Robot.subChassis.stop();
  }

  // Called when another command which requires one or more of the same
  // subsystems is scheduled to run
  @Override
  protected void interrupted() {
  }
}
